DELIVERABLES:
- Your final codebase *** DONE***
- Your revised annotated architecture diagram *** DONE***
- Design justification (including a brief discussion of at least one alternative you considered)*** DONE***
- A map of your game's layout (if applicable) *** DONE***
- cheatsheet.md *** DONE***
- Completed rubric.md *** DONE***





Design justification: When first thinking about the possible games we could create, we knew we wanted to create an escape game or a text-based adventure game based on smith college. Had we not gone down the route we chose, our game would've probably mimicked Zork but would have been made with smith college content. We didn't do the smith text-based adventure because we felt like we would have been using past assignments that we already had and it wouldn't have been as challenging. We would have only had to worry about implementation of our past homework assignments. 
The route we ended up going with allowed us to challenge ourselves.Our game enabled us to unlock our creativity and gave us the opportunity to think deeper about the different components that could go into a game.


REFLECTION Q's:
What was your overall approach to tackling this project?
What new thing(s) did you learn / figure out in completing this project?
Is there anything that you wish you had implemented differently?
If you had unlimited time, what additional features would you implement?
What was the most helpful piece of feedback you received while working on your project? Who gave it to you?
If you could go back in time and give your past self some advice about this project, what hints would you give?
If you worked with a team: please comment on how your team dynamics influenced your experience working on this project.

Reflection: 
Our overall approach to tackling this project was mainly planning our code using psuedocode and constantly referring back to the architecture diagram. The second part was especially the most crucial to our project as it displayed the skeleton of our game. So, it was very important to look back to this as it helped us remember our goals and what we wanted to implement. Something new that we learned was how to implement coordinates or rather location points in the game, as it was something we had never done before. Another thing that was new was creating a game loop that stopped upon user request "reset". This would restart the game, which was cool to see implemented. Overall though, this entire project felt like an entire learning experience. It would've been nice to have implemented the furniture and item classes better, as they were probably the trickiest to tackle. Using inheritance to connect these classes was probably the hardest thing to do, especially when we wanted to do method calls from other classes. 
Furthermore, if we had unlimited time for this project, we would have liked to make the game a lot more challenging and interactive with the user, probably through graphics. With graphics, the user would've been able to see the room we had to describe through text. Smaller things we would've wanted to implement were distractors in the game to make it last a little longer and make it more fun for the user. We also would've wanted the game to communicate to the user their location whenever they took a step. By doing so, it would've made the game more intricate in that it'd be following the user and provide useful information. Likewise, we wanted the game to also tell the user the size of the room so that the user would know how many steps they are able to take. We also experienced a lot of difficulty with making our current version work all together. There are still some missing pieces that aren't allowing the game to run we would've wanted it to. We tried our best with the things we knew, so as a team, we recognize the effort we put in even though we didn't get the result we wanted to see. 
The most helpful piece of advice that we got while working on the project came from Professor Crouser when we discussed the amount of classes we were thinking of implementing. At first, we thought we had to implement numerous subclasses of subclasses of the parent class. This was already sounding unnecessary, so when we discussed it with Professor Crouser, we realized that these classes we wer ethinking of created were simply instances of the subclasses and did not have to be their own separate classes. This definitely saved us a lot of time and confusion. If we could go back in time to give ourselves some advice on this project, we would probably start with the advice Professor Crouser gave us that reinforced the conclusion we'd eventually come to. We'd probably advise our past selves to do some more research on the functions of the game that we were trying to implement, for example: location points. Overall, our team worked well together even though we all had different levels of experience with coding. Even we weren't sure on how to implement something, we asked for help and/or did our best to help in other ways besides code. 